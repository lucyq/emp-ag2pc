#include <emp-tool/emp-tool.h>
#include "emp-ag2pc/emp-ag2pc.h"
#include <openssl/hmac.h>

using namespace std;
using namespace emp;

bool compareHash(uint8_t* sslHash, Integer* empHash) {
  for (int i =0; i < 32; i++) {
    bitset<8> sslBitset(sslHash[i]);
    for (int j = 7; j >= 0; j--) {
      if(empHash[i][j].reveal() != sslBitset[j]) {
        return false;
      }
    }
    cout <<  sslBitset << ", ";
  }
  cout << endl << "TRUE?" << endl;
  return true;
}

void printHash(uint8_t* sslHash) {
  cout << "SSL hmac: ";
  for (int i =0; i < 32; i++) {
    bitset<8> sslBitset(sslHash[i]);
    cout <<  sslBitset << ", ";
  }
  cout << endl;
}

void printArray(bool* empHash) {
  cout << "EMP hmac: ";
  for(int i =0; i < 256; i ++) {
    cout << empHash[i];
  }
  cout << endl;
}

bool compareHash(uint8_t* sslHash, bool* empHash) {
  for (int i =0; i < 32; i++) {
    bitset<8> sslBitset(sslHash[i]);
    for (int j = 7; j >= 0; j--) {
      if(empHash[8*i-j] != sslBitset[j]) {
        return false;
      }
    }
    cout <<  sslBitset << ", ";
  }
  cout << endl << "TRUE!!" << endl;
  return true;
}

int main() {
    const char* message = (char*)"abcdefghabcdefghabcdefghabcdefgh";
    const char* key = (char*)"abcdefghabcdefghabcdefghabcdefgh";
    bool mask[256];
    bool maskedOutput[256];
    
    const char* maskString = (char*)"0101110111111011100000010101110000000111011110000001110001110111100000110100110100110001111101101101000101100010110111001100101011000101011101000100110001100110010000011001111111111000100011001000111110011000111111101010110010010011001000000111010111010101";
    for(int i = 0; i < 256; i ++) {
        mask[i] = maskString[i] == '1';
    }
    const char* maskedOutputString = (char*)"0100010100001111110110011110111101000001101111011001010111001111111011011111100111010111110000011001011011110110101001101101110010100000101100000111000101010010101100000000011101100111010110110000001011110011110110111111001001111110011111000001111110011111";
    // for(int i = 0; i < 256; i ++) {
    //     maskedOutput[i] = maskedOutputString[i] == '1';
    // }
    for(int i = 0; i < 32; i ++) {
      for(int j =0; j < 8; j ++) {
        maskedOutput[i*8+j] = maskedOutputString[i*8 + (7-j)] == '1';
      }
    }
    uint8_t result[32];
    HMAC(EVP_sha256(), key, 32, (const unsigned char*)message, 32, result, NULL);

    bool unmaskedOutput[256];


    // for(int i = 0; i < 256; i ++) {
    //   unmaskedOutput[i] = mask[i] ^ maskedOutput[i];
    // }
    for(int i = 0; i < 32; i ++) {
      for(int j =0; j < 8; j ++) {
        unmaskedOutput[i*8+j] = mask[i*8 + (7-j)] ^ maskedOutput[i*8 + (7-j)];
      }
    }
    printArray(mask);
    printArray(maskedOutput);
    printArray(unmaskedOutput);
    printHash(result);
  // 1111111111010000010110001101010110100001101000111010110100100001001011000100101101011011101011100001110110110000100111011000111100000011100111100100001100110100001100101111111001111000011010101111001111101010101001001100011110110111011110001011000100110100

  // 1111111111010000010110001101010110100001101000111010110100100001001011000100101101011011101011100001110110110000100111011000111100000011100111100100001100110100001100101111111001111000011010101111001111101010101001001100011110110111011110001011000100110100
  // correct ^
    compareHash(result, unmaskedOutput);

  // SSL OUTPUT:
    // 1111111111010000010110001101010110100001101000111010110100100001001011000100101101011011101011100001110110110000100111011000111100000011100111100100001100110100001100101111111001111000011010101111001111101010101001001100011110110111011110001011000100110100
    cout << "Done" << endl; 
}
// ALICE inputs zabc into citcuit:
// 1100110000000110001010011101011100111101110011010000100100100101000110101111111011010010100111000010110111101101010011001111000010110001001101110101100011011110011000001101110110010000001100011101100101110010011001100100100001001100010110000000010100001001


// ALICE's message zabc, SSL output:
// 1101010011011010010011011010010110111011000010001001010000010000101110100100001001011001101101011100001100000110010011100111000000000010110000110010110110010001000010101010001110001010011100000001000001001111110000011100110011101100101010011110101100000111

// BOB's key zabc, SSL output:
// 1100110000000110001010011101011100111101110011010000100100100101000110101111111011010010100111000010110111101101010011001111000010110001001101110101100011011110011000001101110110010000001100011101100101110010011001100100100001001100010110000000010100001001